"""
Keener rating system
"""

# Author: Kyriacos Talattinis <ktalattinis@gmail.com>
#
# Licence: MIT


from typing import Any, Dict, Optional, Tuple

import numpy as np
import pandas as pd
from ratingslib.ratings.rating import RatingSystem
from ratingslib.utils.enums import ratings
from ratingslib.utils.methods import (create_items_dict, get_indices,
                                      indices_and_points, log_numpy_matrix,
                                      parse_columns)
from numpy import linalg as LA


class Keener(RatingSystem):
    """This method has been proposed by James P. Keener in 1993 for football
    teams ranking in uneven paired competition [1]_.
    Keener’s method is based on the theory of nonnegative matrices and forms a
    smoothed matrix of scores generated by Laplace’s rule of succession.

    Parameters
    ----------
    version : str, default=ratings.KEENER
        A string that shows the version of rating system. The available
        versions can be found in :class:`ratingslib.utils.enums.ratings` class.

    normalization : bool, default = True
        If ``True`` then the result will be normalized according to the total
        times each item occurs in the dataset.
        For example in sport teams set normalization = ``True`` if the teams
        haven't played same number of games.

    Attributes
    ----------
    A : numpy.ndarray
        The Keener matrix. It has shape (n, n) where n = the total number of
        items.

    S : numpy.ndarray
        The matrix containing the cumulative number of points scored by each
        item to any other item. It has shape (n, n) where n = the total number
        of items.

    References
    ----------
    .. [1] Keener, J. P., 1993. The Perron-Frobenius theorem and the ranking of football teams. SIAM Review, 35(1), pp. 80-93

    Examples
    --------
    The following example demonstrates Keener rating system,
    for the 20 first soccer matches that took place during the 2018-2019
    season of English Premier League.

    >>> from ratingslib.datasets.filenames import dataset_path, FILENAME_EPL_2018_2019_20_GAMES
    >>> from ratingslib.ratings.keener import Keener
    >>> filename = dataset_path(FILENAME_EPL_2018_2019_20_GAMES)
    >>> Keener(normalization=False).rate_from_file(filename)
                  Item    rating  ranking
    0          Arsenal  0.047220       17
    1      Bournemouth  0.052874        4
    2         Brighton  0.049183       11
    3          Burnley  0.048576       14
    4          Cardiff  0.048243       16
    5          Chelsea  0.052800        5
    6   Crystal Palace  0.049870       10
    7          Everton  0.051214        7
    8           Fulham  0.046829       18
    9     Huddersfield  0.046068       20
    10       Leicester  0.050701        8
    11       Liverpool  0.053796        1
    12        Man City  0.053511        2
    13      Man United  0.050322        9
    14       Newcastle  0.048939       13
    15     Southampton  0.048969       12
    16       Tottenham  0.052569        6
    17         Watford  0.053265        3
    18        West Ham  0.046730       19
    19          Wolves  0.048320       15
    """

    def __init__(self, version=ratings.KEENER, normalization: bool = True):
        super().__init__(version)
        self.normalization = normalization
        self.create_ordered_dict(normalization=self.normalization)
        self.A: np.ndarray
        self.S: np.ndarray

    @staticmethod
    def compute(A: np.ndarray):
        eigvals, eigvecs = LA.eig(A)
        lamvda = max(eigvals.real)
        index = [i for i, j in enumerate(eigvals.real) if j == lamvda]
        rating = abs(eigvecs[:, index[0]].real) / sum(
            abs(eigvecs[:, index[0]].real))
        return rating

    def computation_phase(self):
        self.rating = Keener.compute(self.A)

    def create_keener_matrix(self, data_df: pd.DataFrame,
                             items_df: pd.DataFrame,
                             columns_dict: Optional[Dict[str, Any]] = None
                             ) -> Tuple[np.ndarray, np.ndarray]:
        """Construction of Keener matrix and points matrix S"""
        col_names = parse_columns(columns_dict)
        home_col_ind, away_col_ind, home_points_col_ind, away_points_col_ind =\
            get_indices(col_names.item_i, col_names.item_j,
                        col_names.points_i, col_names.points_j, data=data_df)
        data_np = data_df.to_numpy()
        items_dict = create_items_dict(items_df)

        n = len(items_dict)
        ng = [0 for i in range(n)]

        A = np.zeros((n, n))
        S = np.zeros((n, n))
        for row in data_np:
            i, j, points_ij, points_ji = indices_and_points(
                row, items_dict, home_col_ind, away_col_ind,
                home_points_col_ind, away_points_col_ind)
            S[i][j] += points_ij
            S[j][i] += points_ji
            ng[i] += 1
            ng[j] += 1
        for i in range(n):
            for j in range(n):
                x = (S[i][j] + 1) / (S[i][j] + S[j][i] + 2)
                # different number of games played per team
                if self.normalization and len(set(ng)) != 1:
                    if ng[i] != 0:
                        A[i][j] = self.h_skew(x) / ng[i]
                    else:
                        A[i][j] = self.h_skew(x)
                else:
                    A[i][j] = self.h_skew(x)

        return A, S

    def h_skew(self, x):
        """Skewing function"""
        h = (1 / 2) + ((1 / 2) * np.sign(x - (1 / 2)) * np.sqrt(
            np.abs((2 * x) - 1)))
        return h

    def preparation_phase(self, data_df: pd.DataFrame, items_df: pd.DataFrame,
                          columns_dict: Optional[Dict[str, Any]] = None):
        self.A, self.S = self.create_keener_matrix(data_df, items_df,
                                                   columns_dict=columns_dict)

    def rate(self, data_df: pd.DataFrame, items_df: pd.DataFrame,
             sort: bool = False,
             columns_dict: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        items_df = items_df.copy(deep=True)
        self.preparation_phase(data_df, items_df, columns_dict)
        self.computation_phase()
        items_df = self.set_rating(items_df, sort=sort)
        log_numpy_matrix(self.A, 'A')
        return items_df
