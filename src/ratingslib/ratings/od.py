"""
Offense-Defense rating system
"""

# Author: Kyriacos Talattinis <ktalattinis@gmail.com>
#
# Licence: MIT


import logging
import sys
from typing import Any, Dict, Optional, Tuple

import numpy as np
import pandas as pd
from ratingslib.ratings.rating import RatingSystem
from ratingslib.utils.enums import ratings
from ratingslib.utils.methods import (create_items_dict, get_indices,
                                      indices_and_points, log_numpy_matrix,
                                      parse_columns)
from ratingslib.utils.validation import validate_type


class OffenseDefense(RatingSystem):
    """Offense-Defense is a modified version of ranking algorithm HITS used
    in Ask search engine. This rating system developed by Anjela Govan during
    her PhD [1]_ [2]_ for sport teams rating. The main idea of this method is
    to separate the offensive and defensive strength of each team and the final
    rating vector can be generated by combining offensive and defensive lists.

    Parameters
    ----------
    version : str, default=ratings.OD
        A string that shows the version of rating system. The available
        versions can be found in :class:`ratingslib.utils.enums.ratings` class.

    tol : float, default=0.0001
        Tolerance level

    Attributes
    ----------
    A : numpy.ndarray
        Adjacency matrix of items scores.

    P : numpy.ndarray
        P matrix of OD method.

    defense : numpy.ndarray
        Defense rating vector.

    offense : numpy.ndarray
        Offense rating vector.

    error : float
        Error until convergence.

    iter : int
        Number of iterations to produce convergence of both of the Offense and
        Defense vectors.

    References
    ----------
    .. [1] Govan, A. Y., Langville, A. N., & Meyer, C. D. (2009).
           Offense-defense approach to ranking team sports.
           Journal of Quantitative Analysis in Sports, 5(1)
    .. [2] Govan, A. Y. (2008). Ranking Theory with Application to Popular Sports. 
           Ph.D. dissertation, North Carolina State University.

    Examples
    --------
    The following example demonstrates Offense-Defense rating system,
    for the 20 first soccer matches that took place during the 2018-2019
    season of English Premier League.

    >>> from ratingslib.datasets.filenames import dataset_path, FILENAME_EPL_2018_2019_20_GAMES
    >>> from ratingslib.ratings.od import OffenseDefense
    >>> filename = dataset_path(FILENAME_EPL_2018_2019_20_GAMES)
    >>> OffenseDefense(tol=0.0001).rate_from_file(filename)
                  Item        rating  ranking
    0          Arsenal  1.934298e+00       12
    1      Bournemouth  1.312759e+06        3
    2         Brighton  3.712401e+00       11
    3          Burnley  4.103263e+05        4
    4          Cardiff  4.757391e-04       14
    5          Chelsea  4.576599e+00       10
    6   Crystal Palace  1.049852e+03        7
    7          Everton  2.080318e-07       16
    8           Fulham  1.532621e-12       20
    9     Huddersfield  5.583941e-01       13
    10       Leicester  1.876215e+04        6
    11       Liverpool  3.403605e+12        1
    12        Man City  5.284698e+00        9
    13      Man United  6.223487e+00        8
    14       Newcastle  9.071493e-08       18
    15     Southampton  2.510896e-07       15
    16       Tottenham  9.071797e-08       17
    17         Watford  1.864760e+06        2
    18        West Ham  2.311787e+05        5
    19          Wolves  3.793810e-11       19
    """

    def __init__(self, version=ratings.OD, tol=0.0001):
        validate_type(tol, float, 'tol')
        super().__init__(version)
        self.tol = tol
        self.create_ordered_dict(tol=self.tol)
        self.A: np.ndarray
        self.P: np.ndarray
        self.defense: np.ndarray
        self.offense: np.ndarray
        self.error: float
        self.iter: int

    def computation_phase(self):
        """Compute offense, defense vectors and overall ratings."""
        size = len(self.A)
        e = np.ones(size)
        self.defense = e
        self.error = 1
        self.iter = 0
        while self.error > self.tol:
            oldobar = self.defense
            self.offense = (self.P.conj().transpose()) @ (1 / self.defense)
            self.defense = (self.P) @ (1 / self.offense)
            self.error = float(
                np.linalg.norm(oldobar * (1 / self.defense) - e, 1))
            self.iter += 1
        self.rating = self.offense / self.defense
        logging.info("iterations: %d error: %s tol: %.7f ", self.iter,
                     str(self.error), self.tol)
        log_numpy_matrix(self.offense, 'Offensive vector')
        log_numpy_matrix(self.defense, 'Defensive vector')

    def create_score_matrices(self,
                              data_df: pd.DataFrame, items_df: pd.DataFrame,
                              columns_dict: Optional[Dict[str, Any]] = None
                              ) -> Tuple[np.ndarray, np.ndarray]:
        """Construct score matrix A and P"""
        col_names = parse_columns(columns_dict)
        home_col_ind, away_col_ind, home_points_col_ind, away_points_col_ind =\
            get_indices(col_names.item_i, col_names.item_j,
                        col_names.points_i, col_names.points_j, data=data_df)
        data_np = data_df.to_numpy()
        teams_dict = create_items_dict(items_df)
        epsilon = sys.float_info.epsilon
        n = len(teams_dict)
        A = np.zeros((n, n))
        P = np.full((n, n), epsilon)
        for row in data_np:
            i, j, points_ij, points_ji = indices_and_points(
                row, teams_dict, home_col_ind, away_col_ind,
                home_points_col_ind, away_points_col_ind)
            A[i][j] += points_ji
            A[j][i] += points_ij
        for i in range(n):
            for j in range(n):
                P[i][j] += A[i][j]
        log_numpy_matrix(A, 'od A')
        return A, P

    def preparation_phase(self, data_df: pd.DataFrame, items_df: pd.DataFrame,
                          columns_dict: Optional[Dict[str, Any]] = None):
        """Create A and P matrices"""
        self.A, self.P = self.create_score_matrices(data_df, items_df,
                                                    columns_dict=columns_dict)

    def rate(self, data_df: pd.DataFrame, items_df: pd.DataFrame,
             sort: bool = False,
             columns_dict: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        items_df = items_df.copy(deep=True)
        self.preparation_phase(data_df, items_df, columns_dict)
        self.computation_phase()
        items_df = self.set_rating(items_df, sort=sort)
        return items_df
